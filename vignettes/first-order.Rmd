---
title: "first-order"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{first-order}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r options, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  comment = "#>"
)
```

```{r libraries, setup}
library(doremi)
library(ggplot2)
library(data.table)
library(futile.logger)
set.seed(1)
```


```{r, eval = FALSE, echo = FALSE}
# to supress, just to test locally
source("../R/doremi.R")
source("../R/others.R")
library(futile.logger)
library(lme4)
library(lmerTest)
library(deSolve)
library(zoo)
```

# FIRST ORDER DIFFERENTIAL EQUATIONS

The linear first order differential equation with constant coefficients model is given by the following equation:
$$\tau\frac{dy}{dt}  + (y-y_{eq}) =  ku(t)$$ 
or
$$\frac{dy}{dt}  + \gamma (y-y_{eq}) =  \gamma ku(t)$$
with the initial condition:
$$y(t=0)=y_{0}$$
Where:

* $y(t)$ is the signal to be analyzed

* $\frac{dy}{dt}$ is its first derivative

* $u(t)$ is the excitation term perturbing the dynamics of $y(t)$

And regarding the coefficients:
  
* $\gamma$ is the decay rate.Its inverse, $\tau$ represents the characteristic response time of the solution of the differential equation (i.e. the time it takes to the system to go back to equilibrium)

* $k$ is the gain.  It indicates the proportionality between the stationary increase of $y$ and the constant excitation increase that caused it.

* $yeq$ is the signal equilibrium value. Value reached when the excitation term is 0.

It is common to find this equation with the excitation term set to 0, $u(t)=0$:

$$\frac{dy}{dt}  + \gamma(y-y_{eq}) =  0$$ 

The dynamics in this case follow and exponential decay of the form $y(t)=(y_0-yeq) e^{-\gamma t} + y_{eq}$ and are provoked either by a previous excitation that is no longer present or by the displacement of the system from its equilibrium position (i.e. an initial condition different from 0)

# Two steps analysis procedure

The estimation of the fixed effect coefficients of the differential equation is performed in two steps. The first step consist in estimating the first derivative, using one of the three method proposed.

The second step consist in performing the following multilevel regression:

\begin{equation}
\dot{y}_{ij} \sim (b_{0}+b_{0j})+ (b_1 + b_{1j})y_{ij}+ (b_2 + b_{2j}) U_{ij}+e_{ij} 
\label{eq2}
\end{equation}

where:
  
* i accounts for the time
* j accounts for the different individuals
* $\dot{y}_{ij}$ is the derivative estimated through one of the derivative estimation methods available in the package (gold, glla and fda) calculated on embedding points (gold, glla) or estimated on the time points provided (fda) 
* $y_{ij}$ and $U_{ij}$ are the variable and the excitation averaged on embedding points (gold, glla) or the originals provided (fda)
* $e_{ij}$ is the error term (residuals)

Note that random effects are estimated for the intercept ($b_{0} + b_{0j}$), variable ($b_{1} + b_{1j}$) and excitation terms ($b_{2} + b_{2j}$), so that individuals can have different coefficients (initial condition, damping time, gain and equilibrium value).

The fixed effect coefficient estimated from the regression are

* $ gamma =  b_{1} $
* $yeqgamma =  b_{0} $
* $kgamma =  b_{2} $

The coefficients of the diferential equation can be thus calculated as:

* Decay time: $tau = \tau = \frac{1}{b_{1}}$  
* Gain: $k = \frac{b_{2} }{b_{1}}$
* Equilibrium value: $yeq = \frac{b_{0} }{b_1}$ 

The estimation is performed using the function `lmer` if there are several individuals or `lm` if there is a single individual.

# First order differential equation with no excitation term

## Simulating data 

In this section, we present increasingly complex examples of data simulation for the first order differential equation model functions included in the package.

### Example 1a - Generating signals with no noise

In this example we will generate data for 4 individuals, with a decay time of 10s. That is, the signal follows exactly the differential equation (no measurement noise) with no variation of the decay time, the gain and the equilibrium value across individuals (no interindividual noise). As we are considering no excitation, then, as mentioned, the system should be out of its equilibrium value to observe the dynamics of return to equilibrium.

```{r simulation example1a}
res1a <- generate.panel.1order(time = 0:99,
                               y0 = 1,
                               tau = 10,
                               nind = 4)
```

As it can be seen, it can be specified to the function whether there is an excitation or not by setting the input to NULL or directly ignoring it in the input arguments. The function returns a data.table with the class 'doremidata'. As any data.table, it can be visualized using the `str` or `head` functions or entering the variable name.
```{r res1a}
res1a
```

Where:
  
* id is the identifier of the individual

* time is the time vector introduced as input

* signalraw is the signal without noise

* signal is the signal with noise (in this case, the values of this column are the same as those of the signalraw column and in the plot, you will see that both lines are overlapped). 


Plotting the data with the plot method available in the package for doremidata objects is quite straight forward:
```{r plot res_1a, fig.align="center", fig.height=6, fig.width=7}
plot(res1a)
```  

### Example 1b - Changing initial condition, gain and equilibrium value

In this example we will show the flexibility of the functions to add changes on the mentioned parameters. For this, we will simplify the form of the exitation to a simple step:

```{r changing initial condition res1b}
timevec <- 0:49
res1b <- generate.panel.1order(time = timevec,
                               excitation = as.numeric(timevec > 20),
                               y0 = 3,
                               tau = 5,
                               yeq = 1.5,
                               nind = 4)
```


```{r changing initial condition plot res1b,fig.width = 7, fig.height = 6, fig.align = "center"}
plot(res1b) + scale_y_continuous(limits = c(0, 3))
```

### Example 2a - Generating signals with noise
The call to the function remains almost the same, this time we have added a noise to signal ratio of 0.2 and a 40% inter-individual noise to visualize the different trajectories for the different individuals:

```{r noise res2a}
# Generation of signals with intra and inter-noise
res2a <- generate.panel.1order(time = 0:49,
                               y0 = 1,
                               tau = 5,
                               nind = 6,
                               internoise = 0.4,
                               intranoise = 0.1)
```

```{r noise plot res2a, fig.width = 7, fig.height = 6, fig.align = "center"}
plot(res2a)
```

## Analyzing data

### Example 3 - Analyzing data when the excitation is unknown, with some inter- and intraindividual noise

We will test how the analysis functions fit a decreasing exponential, as is the case when there is no excitation, when it is unknown, or when it is constant over time.  

```{r analysis example3}
#Simulating data with these hypothesis
data3 <- generate.panel.1order(time = 0:50,
                               y0 = 0.5,
                               tau = 10,
                               nind = 3,
                               internoise = 0.2,
                               intranoise = 0.1)
```

```{r analysis res3}
#Analyzing

res3 <- analyze.1order(data = data3,
                      id = "id",
                      time = "time",
                      signal = "signal",
                      dermethod = "fda",
                      derparam = 0.7)
```
Note that the `input` parameter has been omitted when calling the function. 
The result display the summary of the fixed effect cefficients:

```{r}
res3
```
The data.table `result_id` gives the coeficients estimated for each individual:
```{r}
res3$resultid
```

It is possible to use the `plot` funciton directly on the result of the analysis:

```{r  analysis plot res3,fig.width = 7, fig.height = 6, fig.align = "center"}
#Plotting
plot(res3)
```

# First order differential equation with an excitation term

Analyzing the signals with noise generated above, we can verify that the parameters were the one introduced in the simulation function and that the estimated signals generated match the simulated ones.

# Simulating data
## Example 1a - Generating signals with no noise

In this example we will generate data for 4 individuals, with a decay time of 10s for an excitation vector formed by 3 pulses of amplitude 1 and duration 10s distributed randomly in a time period of 100s, with a minimum spacing between pulses of 20 s and with no noise. That is, the signal follows exactly the differential equation (no measurement noise) with no variation of the decay time, the gain and the equilibrium value across individuals (no interindividual noise). 
```{r excitation term example1a}
U1a <- generate.excitation(amplitude = 1,
                           nexc = 3,
                           duration = 10,
                           deltatf = 1,
                           tmax = 100,
                           minspacing = 20)
                               
res1a <- generate.panel.1order(time = U1a$t,
                               excitation = U1a$exc,
                               tau = 10,
                               k = 1,
                               nind = 4)
plot(res1a)
```
## Example 1b - Changing initial condition, gain and equilibrium value
In this example we will show the flexibility of the functions to add changes on the mentioned parameters. For this, we will simplify the form of the exitation to a simple pulse:

```{r changing initial condition}
U1b <- generate.excitation(amplitude = 1,
                           nexc = 1,
                           duration = 50,
                           deltatf = 1,
                           tmax = 100,
                           minspacing = 20)
                               
res1b <- generate.panel.1order(time = U1b$t,
                               excitation = U1b$exc,
                               y0 = 3,
                               tau = 10,
                               k = 5,
                               yeq = 2,
                               nind = 4)
```

```{r plot res1b,fig.width = 7, fig.height = 6, fig.align = "center"}
plot(res1b)
```

And it can be observed how the system tends to equilibrum (2) from the initial condition (3) then to a new equilibrium after perturbed by the excitation (saturation at $yeq + ku(t)=2 + 5*1=7$) and then new return to equilibrium after the excitation is gone.

## Example 2 - Generating signals with noise
The call to the function remains almost the same, this time we have added a signal to noise ratio (STN) of 1/0.2=5 and a 40% inter-individual noise to visualize the different trajectories for the different individuals:

```{r example2}
# Generation of signals with intra and inter-noise
U2a <- generate.excitation(amplitude = 1,
                           nexc = 3,
                           duration = 10,
                           deltatf = 1,
                           tmax = 100,
                           minspacing = 20)
res2a <- generate.panel.1order(time = U2a$t,
                               excitation = U2a$exc,
                               tau = 10,
                               k = 1,
                               nind = 4,
                               internoise = 0.1,
                               intranoise = 2)
```

```{r plot res2a,fig.width = 7, fig.height = 6, fig.align = "center"}
plot(res2a)
```

# Analyzing data

## Example 3 - Analyzing data from a single individual

In this case, we can reuse one of the signals from the previous example

```{r example3}
data3 <- data.frame(U2a, 
                 signalcol = res2a[id==1]$signal)
```

As the table contains data from a single individual,  the `id` parameter has been omitted when calling the function.

```{r res3}
#Analyzing
res3 <- analyze.1order(data = data3,
                      input = "exc",
                      time ="t",
                      signal = "signalcol",
                      verbose=T)
res3
```

```{r plot res3,fig.width = 6, fig.height = 4, fig.pos = 0.5, fig.align = "center"}
#Plotting 
plot(res3)
```

## Example 3a - Analyzing data with several individuals and some inter and intra-individual noise

Analyzing the data generated in the example 2 above (table res2a), the user must specify the name of the columns containing the id of the participants, the excitation, and the signal.
As several methods are available for the estimation of the derivatives, the user needs to specify which method to use (`gold` is the default) and the embedding dimension by modifying the parameter "derparam" (see the package pdf manual for more details).

```{r analysis res3a}
res3a <- analyze.1order(data = res2a,
                        id = "id",
                        input ="excitation",
                        time ="time",
                        signal = "signal",
                        dermethod = "gold",
                        derparam = 3)
```

Now let’s take a look at the result. When calling the variable, the fixed effect coefficients of regression with their associated standard error, the derived coefficient characterizing the signal shape (the decay time tau, the equilibrium value yeq and the gain k), and the R2 are displayed:
  
```{r analysis res3a print}
res3a 
```
The signal analyzed was generate with tau = 10, yeq = 0, and k = 1. 
  
This is a simplified view of the results. The analysis function supplies an object of class “doremi” that contains in fact several lists. It is possible to explore the full result values by using the function "summary" for doremi objects (see the section on methods created for doremi objects at the end of this vignette).

```{r summary res3a}
summary(res3a) 
```

The first object of the output contains the original data with some columns added. These columns contain intermediate variables necessary for the mixed-effect regression:

```{r head res3a}
head(res3a$data)
```

Where:
  
* signal_rollmean contains the zeroth order derivative of the input signal in embedding points provided by `gold` or `glla`, or the smoothing performed by `fda`.

* signal_derivate1 contains the first derivate of signal, calculated by using one of the derivative estimation methods available (`gold`, `glla`, `fda`).

* time_derivate contains the values of time in which the derivative has been evaluated.

* excitation_rollmean contains the roll mean of the excitation signal in embedding points (gold, glla) or in the initial time points provided (`fda`).


If we want to visualize the summary of the mixed-effect regression:
  
```{r components of res3a}
res3a$regression
```

Where we have the random and fixed effects and the residuals calculated by the function `lmer` or `lm` depending on if the sample had several or one individual respectively. 

Beware that, as known in the two-steps procedures, the estimation of derivatives is a source of bias and thus the error terms provided by the regression are not final. 

The following table contains the fixed effect coefficients (result displayed by default when calling a doremi variable, as mentioned before):

```{r resultmean}
res3a$resultmean
```

It can be observed that the decay time is close to the value introduced to the simulation function (6), the equilibrium value close to its true value (0), and the gain close to its true value (1). For each individual we have:
  
```{r resultid}
res3a$resultid
```

Where:

* tau is the decay time. 
* yeq is the equilibrium value.
* excitation_k is the gain associated to the excitation "excitation". As we will see later, there is the possibility to consider several excitations, each one of which will have a different effect on the dynamics of the signal studied and thus, a different gain associated to them.

If we graphically wish to verify how the estimated signal fits the initial signal, we can once again call the function `plot`, that has been adapted to handle doremi objects as well:

```{r plot res3a,fig.width = 7, fig.height = 6, fig.align = "center"}
plot(res3a)
```

Similarly to the `print` function, `plot` applied to a doremi object plots by default the first six individuals contained in the result. If we wish to visualize a single individual or a specific set of individuals, we can specify them by changing the "id" input parameter of the function:

```{r more plot res3a,fig.width = 7, fig.height = 6, fig.align = "center"}
plot(res3a, id = 3)
plot(res3a, id = c(1,4))
```

Finally, the result contains the derivative method used and the embedding number/smoothing parameter used for further reference.

## Example 3b - Enhancing the fit by changing the embedding number/ smoothing parameter.
As it was mentioned before, the estimation of derivatives is a source of bias. It is possible to enhance the quality of the fit in three ways:

* By changing the embedding number/smoothing parameter

* By changing the order of the derivative

* By changing the derivation method

In the following example, we will use the function `optimum_param` to find the embedding number that provides the closest R2 to 1. The other ways can be tested "manually" by calling the other functions, for instance, in a simulation study.
Let us first generate some data to analyze:


```{r}
plot(res2a)
```


```{r res3b}
res3b <- optimum_param (data = res2a,
                      id = "id",
                      input = "excitation",
                      time = "time",
                      signal = "signal",
                      model = "1order",
                      dermethod = "gold",
                      pmin = 3,
                      pmax = 21,
                      pstep = 2)

res3b$summary_opt
res3b$d
```

And it can be seen that, from the range provided, an embedding number of 7 produces the best fit and that the coefficients are closer to their true values than the ones estimated in the previous example.

THe optimum_param function, generates an object of class "doremiparam". If we want to graphically see the evolution of the coefficients according to the embedding number, we can easily plot the results with the `plot` function too:

```{r plot res3b,fig.width = 7, fig.height = 6, fig.align = "center"}
plot(res3b)
```

## Example 4 - Analyzing data when the signal is subject to several excitations 

In this example, we construct a signal having different gain for different excitation sources. For the sake of simplicity, we generate this example signal without noise.


```{r example4}
#Simulating data with these hypothesis
#Generating the three excitation signals:
t <- 0:100
u1 <- as.numeric(t>20 & t<40)
u2 <- as.numeric(t>50 & t<70)
u3 <- as.numeric(t>80 & t<100)
# Arbitrarily choosing a = 1, b = 2 and c = 5 for the first individual
et1 <- u1 + 3 * u2 + 5 * u3
y1 <- generate.1order(time = t,
                      excitation = et1,
                      tau = 10,
                      k = 1)$y
#as we are using the $y argument of the object generated

#Signals for the second individual;
# Arbitrarily choosing a = 1, b = 2.5 and c = 4 for the second individual
et2 <- u1 + 2.5 * u2 + 4 * u3
y2 <- generate.1order(time = t,
                      excitation = et2,
                      tau = 10,
                      k = 1)$y 

#Generating a table with the signals
data4 <- data.frame(id = rep(c(1, 2), c(length(et1), length(et2))), 
                 time = c(t, t),
                 excitation1 = c(u1, u1),
                 excitation2 = c(u2, u2),
                 excitation3 = c(u3, u3),
                 signalcol = c(y1, y2))
```

We have in data4 a signal, whose dynamics has been provoked by three excitation with different gains: k =  1, 3 and 5 for id = 1, k = 1, 2.5 and 4 for id = 2. We can see in the graph below that each excitation is identical but provoke a different change of the signal:

```{r plot example4,fig.width = 7, fig.height = 4, fig.align = "center"}
#Plotting signals
ggplot2::ggplot( data = data4) +
  ggplot2::geom_line(ggplot2::aes(time,signalcol, colour = "Signal-no noise"))+
  ggplot2::geom_line(ggplot2::aes(time,excitation1,colour = "excitation 1"))+
  ggplot2::geom_line(ggplot2::aes(time,excitation2,colour = "excitation 2"))+
  ggplot2::geom_line(ggplot2::aes(time,excitation3,colour = "excitation 3"))+
  ggplot2::facet_wrap(~id)+
  ggplot2::labs(x = "Time (s)",
           y = "Signal (arb. unit)",
           colour = "")
```

It is possible in `analyze.1order` to give a vector of column as input. In this case, a gain will be estimated for each excitation column.

```{r res4}
#Analyzing signals
res4 <- analyze.1order(data = data4,
                       id = "id",
                       input = c("excitation1", "excitation2", "excitation3"),
                       time = "time",
                       signal = "signalcol",
                       dermethod = "fda",
                       derparam = 0.1)

#Looking for the calculation of the coefficients of the excitation

res4$resultid

```

Here, we recover the estimated gains for each individual in the `resultid` table. It can be seen that they are a good approximation of the coefficients introduced, using this small sample of 2 individuals.

```{r fig.width = 7, fig.height = 4, fig.align = "center"}
#Plotting signals
plot(res4)
```


## Example 5 - Analyzing data when there are some missing points in the signal

When simulating signals with missing measurements, we show below how the analysis function still manages to retrieve a reasonable accurate fit:

```{r example5}
t <- 0:200
data5 <- generate.panel.1order(time = t,
                               excitation = as.numeric(t>50 & t<100),
                               tau = 10,
                               k = 1,
                               nind = 6,
                               internoise = 0.4,
                               intranoise = 0.1)
```

```{r plot data5, fig.width = 7, fig.height = 6, fig.align = "center"}
plot(data5)
```


```{r missing data}
#Keeping one third of the rows selected randomly from the full data set
data5rd <- as.data.table(data5[sample(nrow(data5), nrow(data5)/3), ])
data5rd <- data5rd[order(id,time)]
```

In the next plot we show the selection of random points made on the full data set. The signal without noise has been represented in order show the selection of points made. However, the signal with noise will be used to carry out the analysis.

```{r plot missing data,fig.width = 7, fig.height = 6, fig.align = "center"}
ggplot2::ggplot( data = data5rd ) +
  ggplot2::geom_line(ggplot2::aes(time,excitation,colour = "Excitation"))+
  ggplot2::geom_point(ggplot2::aes(time,signal, colour = "Random sampling"))+
  ggplot2::facet_wrap(~id)+
  ggplot2::labs(x = "Time (unit)",
           y = "Signal (unit)",
           colour = "")
```

Then analyzing and visualizing the random points selection:
  
```{r res7}
res7 <- analyze.1order(data = data5rd,
                       id = "id",
                       input = "excitation",
                       time ="time",
                       signal = "signal")
```


```{r  plot res7,fig.width = 7, fig.height = 6, fig.align = "center"}
ggplot2::ggplot( data = data5 ) +
  ggplot2::geom_line(ggplot2::aes(time,signalraw, colour = "Original signal"))+
  ggplot2::geom_line(ggplot2::aes(time,excitation,colour = "Excitation"))+
  ggplot2::geom_point(data = data5rd, ggplot2::aes(time,signal, colour = "Random sampled signal"))+
  ggplot2::geom_line(data = res7$data, ggplot2::aes(time,signal_estimated, colour = "Estimated signal. Missing data points"))+
  ggplot2::facet_wrap(~id)+
  ggplot2::labs(x = "Time (unit)",
           y = "Signal (unit)",
           colour = "") +
  ggplot2::theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5))


```

# C - Applications

## Heart rate during effort tests

Using the `cardio` dataset present in this package, we will apply the model to real heart frequency measurements. The data fields are described with detail in the pdf manual of the package, together with the source from which the data was obtained.
In brief, the data consists on  heart rate measurements from 21 individuals carrying out an effort test on a cycle ergometer. Participants pedal on a bicycle with increasing resistance. The resistance load is measured in watts, with higher load forcing the individual to greater effort. His/her heart frequency will then vary according to the effort supplied and the participant’s fitness. According to this, the `cardio` data includes, for each individual, the time since the beginning of the test (seconds), the bicycle load (Watts) and the heart rate (1/min).

```{r cardio data}


resc1a <- analyze.1order(data = cardio,
                 id = "id",
                 input = "load",
                 time ="time",
                 signal = "hr",
                 dermethod = "glla",
                 derparam = 5)
```

Plotting analysis results for all 21 participants. Note that omitting the argument `id` would lead to only the first 6 participants being plotted by default.

```{r plot cardio data,fig.width = 7, fig.height = 16, fig.align = "center"}
plot(resc1a, id = 1:21) + 
  ggplot2::facet_wrap(~id,ncol=3,scales="free")
```

As can be seen, the model reproduces reasonably well the variation of the heart rate, and can be used to fully characterize the heart rate dynamics with three simple parameters: the resting heart rate (the equilibrium value), the characteristic time of heart rate change (the decay time), and the increase of heart rate for a given effort (the gain).

## Measuring heart frequency during effort tests by considering several excitations
In the previous example, each one of the steps in the resistance load can be considered as a separated perturbation having an effect on heart rate. In this case, the functions will estimate different gains as explained, to account for each one of the contributions of the load to the total heart rate dynamics. 

```{r cardio multiple excitations}
mydata <- cardio[id %in% 1:10]

# create a index indicate which step of the exercise test 
mydata[,load_idx := rleid(load),by = id]
# transforming to large format, to have one column per workload step
mydata_large <- dcast(id + time + hr  ~ paste0("load_",load_idx),data = mydata,value.var = "load")
# replacing NAs by 0s
load_cols <- paste0("load_",1:max(mydata$load_idx))
mydata_large[,c(load_cols) := lapply(.SD,function(col) fifelse(is.na(col),0,col)),.SDcols = load_cols]

# analyzing
resc1b <- analyze.1order(data = mydata_large,
                        id = "id",
                        input = load_cols,
                        time = "time",
                        signal = "hr",
                        dermethod = "gold",
                        derparam = 5)
```

Here we will estimate a gain per excitation column
```{r}
resc1b
```

In the plot, each workload step of the exercise test appear in one different column.

```{r plot cardio mult excitations,fig.width = 7, fig.height = 16, fig.align = "center"}
plot(resc1b,id=1:10)+ ggplot2::facet_wrap(~id,ncol=3,scales="free")
```


## Measurements of response time of individuals when carrying out mental rotation tasks

Using the `rotation` dataset present in this package, we will apply the model to a case in which the excitation signal is not clearly defined.
In brief, the data is from 17 individuals that carried out mental rotation tasks (identify if two figures, one of which is rotated, are the same or a mirror image) and the response time (in milliseconds) was measured [(Courvoisier et al., 2013)](https://doi.org/10.1016/j.yhbeh.2012.12.007). Each individual was measured every day for 60 days, though there can be missing data. To account for this, the time has been represented by the number of days since the beginning of the experiment (variable `days`). The signal is the mean response time (variable `meanRT`) over the ~200 stimuli done every day. The purpose of the study was to compare the performance between men and women.

```{r mental rotation data}
dermethod<- "fda"
pmin = 0.1
pmax = 1
pstep = 0.1

restemp <- optimum_param(data = rotation,
                          id = "id",
                          time ="days",
                          signal = "meanRT",
                          dermethod = dermethod,
                          model = "1order",
                          pmin = pmin,
                          pmax = pmax,
                          pstep = pstep)
restemp$summary_opt
resc2a <- analyze.1order(data = rotation,
                 id = "id",
                 time ="days",
                 signal = "meanRT",
                 dermethod = dermethod,
                 derparam = restemp$d)
```

Plotting analysis results:

```{r plot menta rotation data,fig.width = 7, fig.height = 6, fig.align = "center"}
plot(resc2a, id = 1:17)
```

# D - Print, summary, plot and predict with doremi objects

As seen earlier, it is possible to print a doremi object by just calling the variable in which the doremi object is stored. It is also possible to print a summary of it by using the `summary` function available in R and to plot it directly using the `plot` function. In the same way, a S3 method for the `predict` function has been included to handle doremi objects. Thus, it is possible to carry out an analysis of a given signal and excitation and then use the analysis results to predict the signal that would have occurred if another different excitation had happened. Taking example 4, we will select only the first individual, and the first part of the data to have a single excitation. We will then use the results to carry out a prediction of the second signal to the second excitation. Finally, we will verify that the result of the predict function matches the second signal.
  
```{r   print summary predict, fig.width = 5,fig.height = 4, fig.pos = 0.5, fig.align = "center"}
#Input data from previous example
datad1 <- setDT(data4)[id==1,.(id,time,excitation,signalcol)]

#Analysis 
resd1 <- analyze.1order(data = datad1,
                        input = "excitation",
                        time = "time",
                        signal = "signalcol",
                        dermethod = "glla",
                        derparam = 7)
                                 
#Creating data frame with et2 that will be supplied as new excitation for the predict function
datad1n <- copy(datad1)
datad1n$excitation <- as.numeric(datad1$time>50 & datad1$time<60)


#Calling the predict function
predresd1<- predict(resd1,
                    newdata = datad1n)

#Comparing predicted value with signal y2
ggplot2::ggplot(data = predresd1$data) +
ggplot2::geom_point(ggplot2::aes(time, signalcol_estimated,colour = "predicted signalcol")) +
ggplot2::geom_point(ggplot2::aes(time, signalcol,colour = "signalcol")) +
ggplot2::geom_line(data= datad1, ggplot2::aes(time, excitation,colour = "Original excitation")) + 
ggplot2::geom_line(data= datad1n, ggplot2::aes(time, excitation,colour = "New excitation"))  

```


