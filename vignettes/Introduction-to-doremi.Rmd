---
title: "Introduction-to-doremi"
author: "Adriana Uribe"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to doremi}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{ggplot2}
  %\VignetteDepends{data.table}
```{r}
devtools::load_all("C:/Users/Alba/Documents/Unige/doremi")
```

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  comment = "#>"
)
```

The main purpose of the dynamics of return to equilibrium during multiple inputs (doremi) model included in this package is to be able to fit trends of homeostasis and return to equilibrium in noisy data. doremi estimates coefficients for the solution of a first order differential equation using linear mixed-effects (multilevel) models. 
The differential equation considered is the following:

$\dot{y}(t) + \gamma y(t) = \epsilon E(t) + eqvalue$ (1)

Where the variables:

* y(t) is the signal to be analyzed

* $\dot{y}(t)$ is its first derivative

* E(t) is the excitation term creating the dynamics of y(t)

And regarding the coefficients:

* $\gamma$ is the damping rate, the inverse of which is the damping time. The damping rate indicates the relative variation of the signal with respect to time when the excitation term is 0.
The damping time is the characteristic response time of the solution to equation (1), After an excitation, when the signal returns to a lower equilibrium level, the damping time corresponds to the time needed to reach ~37% (1/e) of the difference between the level reached and the equilibrium value.

```{r fig.width = 7, fig.height = 6, include = FALSE}
exc <- rep(c(0,1,0),c(10,30,50))
signal<- generate.remi(10, exc, seq(1:90))
temp <- paste("theta")

ggplot2::ggplot(data = data.table::setDT(signal)) +
ggplot2::ggtitle( "Definition of damping time")+
  ggplot2::geom_point(ggplot2::aes(t,y, colour = "Signal"))+
  ggplot2::geom_line(ggplot2::aes(t,exc, colour = "Excitation"))+
  ggplot2::geom_hline(yintercept=0.63*max(signal$y), linetype="dashed", colour = "gray")+
  ggplot2::geom_hline(yintercept=0.37*max(signal$y), linetype="dashed", colour = "gray")+
  ggplot2::geom_vline(xintercept=signal$t[signal$y==max(signal$y)], linetype="dashed", colour = "gray")+
  ggplot2::geom_vline(xintercept=50, linetype="dashed", colour = "gray")+
  ggplot2::geom_vline(xintercept=19, linetype="dashed", colour = "gray")+
  ggplot2::geom_vline(xintercept=10, linetype="dashed", colour = "gray")+
  ggplot2::annotate("segment", x = 10, xend = 19, y = -0.5, yend = -0.5, colour = "dark green", size = 1)+
  ggplot2::annotate("text", x = 15, y = -1, label = "tau", parse = TRUE, colour = "dark green")+
  
  ggplot2::annotate("segment", x = 40, xend = 50, y = -0.5, yend = -0.5, colour = "dark green", size = 1)+
  ggplot2::annotate("text", x = 45, y = -1, label = "tau", parse = TRUE, colour = "dark green")+

  ggplot2::annotate("text", x = 75, y = 6.6, label = "63% diff. max and eq. value", colour = "gray")+
  ggplot2::annotate("text", x = 75, y = 4, label = "37% diff. max and eq. value", colour = "gray")+
  
  ggplot2::labs(x = "Time (arb. unit)",
           y = "Signal (arb. unit)",
           colour = "Legend")+
  ggplot2::theme(legend.position = "top",plot.title = element_text(hjust = 0.5))
```

* $\epsilon$ is the excitation coefficient, also called "gain" in control theory. It indicates the relationship between the signal and the input (also called excitation).

* _eqvalue_ is the equilibrium value, that is, the value the system has when there is no excitation and no remaining effect of previous excitation (i.e., when t tends to infinity).

In order to find these coefficients, the model performs the following linear mixed-effect regression derived from equation (1), as presented by [(Mongin et al.,2018)](https://doi.org/10.1080/00273171.2010.498294):

$\dot{y}_{ij} \sim b_{0}+b_{0i}+b_{1}y_{ij}+b_{2}E_{ij}+u_{1j}y_{ij}+u_{2j}E_{ij}+e_{ij}$ (2)

where:
* i accounts for the time

* j accounts for the different individuals

* $\dot{y}_{ij}$ is the derivative calculated on $N_{E}$ points through the Gold method [(Deboeck,2010)](https://doi.org/10.1080/00273171.2010.498294) to avoid the appearance of correlated errors in the estimation

* y and E are the signal and the excitation averaged on $N_{E}$ points

* $e_{ij}$ is the error term

Note that random effects are estimated for the intercept $b_{0} +b_{0i}$, signal $b_{1} +u_{1j}$ and excitation terms $b_{2} +u_{2j}$, , so that individuals can vary on their initial level, their evolution over time and their reaction to an excitation.

The coefficients aforementioned can be thus calculated as:

* Damping time: $\tau_{i} = \frac{1}{\gamma_{i}}$  with $\gamma_{i} =  b_{1} + u_{1j}$

* Excitation coefficient: $\epsilon = \frac{b_{2} + u_{2j}}{\gamma_{i}}$

* Equilibrium value: $eqvalue = \frac{b_{0} + b_{0i} }{\gamma _{i}}$ 

The estimation is performed using the function [lmer](https://CRAN.R-project.org/package=lme4) if there are several indiviuals or [lm](http://stat.ethz.ch/R-manual/R-devel/library/stats/html/lm.html) if there is only one.

With the above estimated parameters, the estimated signal can be reconstructed for each individual as the analytical solution to equation (1) is known:

$y(t) = \frac{\epsilon}{\tau}\int E(t')G(t-t')dt'+ eqvalue$ (3)

Where y(0) = eqvalue and G(t) is the Green function, that is, the function that satisfies the differential equation when the excitation term is a Dirak delta function. In our case, it is a decreasing exponential of the form:
$$G(t) = exp(\frac{-t}{\tau})$$ 

The estimated signal is then built by first performing the convolution of the excitation with the Green function -using the estimated damping rate- and then offsetting the resulting signal with the equilibrium value.
The package contains three types of functions:

### Simulation functions
These are functions that allow the user to create data corresponding to a first order differential equation (ie. solution of equation (1)). The simulation functions presented in the file are:


* **generate.remi:** Creates the solution of equation (1) for a given damping time and excitation vector.


* **simulate.remi:** creates a set of signals that are solution of equation (1) for a random simulated excitation. Number of points, damping time, intra-individual noise and inter-individual noise can be controlled.

### Analysis functions
The analysis function presented in the file is:


* **remi:** the function performs the presented mixed-effects regression (2) and provides the calculated derivatives, the differential equation coefficients per individual and averaged, the fixed and random coefficients coming from the fit and the estimated signals, according to (3).

### Auxiliary functions
These functions are used by the simulation and/or analysis functions but they can also be used independently:

* **generate.excitation:** generates a random succession of squared pulses for a given number of points, number of pulses, amplitude and duration (used for simulation purposes only).

* **calculate.gold:** calculates the derivative of a group of data points by using the Gold method [(Deboeck, 2010)](https://doi.org/10.1080/00273171.2010.498294) (used in the analysis function only).

# A - Simulating data 

In this section, we present increasingly complex examples of data simulation.

## Example 1 - Generating signals with no noise

Generating data for 4 individuals, with a damping time of 10s for an excitation vector formed by 3 excitations of amplitude 1 and duration 10s distributed randomly in a time period of 100s, with a minimum spacing between pulses of 20 s and with no noise. That is, the signal follows exactly the differential equation (no intraindividual noise) with no variation of the damping time, the excitation coefficient and the equilibrium value across individuals (no interindividual noise):

```{r}
mydataa1 <- simulate.remi(nind = 4, 
                          dampingtime = 10, 
                          amplitude = 1, 
                          nexc = 3, 
                          duration = 10, 
                          deltatf = 0.5,
                          tmax = 100,
                          minspacing = 20,
                          internoise = 0, 
                          intranoise = 0)
```

The function returns the data as an output value, which can be visualized using the [str] or [head] functions. Entering “mydataa1” directly will allow you to visualize the first and last lines.

```{r}
mydataa1
```

Where:
* id is the identifier of the individual

* excitation is the excitation signal

* dampedsignalraw is the signal without noise

* dampedsignal is the signal with noise (in this case, the values of this column are the same as those of the dampedsignalraw column and in the plot, you will see that both lines are overlapped). 

* timecol is the time column generated.

Plotting data:

```{r fig.width = 7,fig.height = 6}
ggplot2::ggplot( data = mydataa1$data ) +
  ggplot2::geom_line(ggplot2::aes(timecol,dampedsignalraw, colour = "dampedsignalraw"))+
  ggplot2::geom_point(ggplot2::aes(timecol,dampedsignal, colour = "dampedsignal"))+
  ggplot2::geom_line(ggplot2::aes(timecol,excitation,colour = "Excitation"))+
  ggplot2::facet_wrap(~id)+
  ggplot2::labs(x = "Time (s)",
           y = "Signal (arb. unit)",
           colour = "")
```

## Example 2 - Generating signals with noise
The call to the function remains almost the same, this time adding a 20% intra-individual noise and a 40% inter-individual noise:

```{r}
# Generation of signals with intra and inter-noise
mydataa2 <- simulate.remi(nind = 4, 
                          dampingtime = 10, 
                          amplitude = 1, 
                          nexc = 3, 
                          duration = 10, 
                          deltatf = 0.5,
                          tmax = 100,
                          minspacing = 20,
                          internoise = 0.4, 
                          intranoise = 0.2)
```

```{r fig.width = 7,fig.height = 6}
# Plotting the data
ggplot2::ggplot( data = mydataa2$data ) +
  ggplot2::geom_line(ggplot2::aes(timecol,dampedsignalraw, colour = "Signal-no noise"))+
  ggplot2::geom_point(ggplot2::aes(timecol,dampedsignal, colour = "Signal with 20% intra-noise"))+
  ggplot2::geom_line(ggplot2::aes(timecol,excitation,colour = "Excitation"))+
  ggplot2::facet_wrap(~id)+
  ggplot2::labs(x = "Time (s)",
           y = "Signal (arb. unit)",
           colour = "")
```

# B - Analyzing data

Analyzing the signals with noise generated above, we can verify that the damping coefficient was the one introduced in the simulation function and that the estimated signals generated match the simulated one.

## Example 1 - Analyzing data with several individuals and some inter and intra-individual noise

Analyzing the data generated in example 2 above, the user must specify the name of the columns containing the id of the participants, the excitation, and the signal. In addition, the user must also indicate the embedding number. The embedding number is the number of data points used to compute the first derivative using the Gold method (see manual for more details).

```{r}
resultb1 <- remi(data = mydataa2,
                 id = "id",
                 input ="excitation",
                 time ="timecol",
                 signal = "dampedsignal",
                 embedding = 5)
```

Now let’s take a look at the result. When calling the variable, the mean three coefficients of the differential equation found are displayed:
  
```{r}
resultb1 
```
  
This is a simplified view of the results. The analysis function supplies an object of class “doremi” that contains in fact several lists. It is possible to explore the full result values by using the function "summary" for doremi objects (see the section on methods created for doremi objects at the end of this vignete).

```{r}
summary(resultb1) 
```

The first object of the output contains the original data with some columns added. These columns contain intermediate variables necessary for the mixed effect regression:

```{r}
head(resultb1$data)
```

Where:
  
* dampedsignal_rollmean contains the roll mean (moving average) values of the input signal in embedding points. 

* dampedsignal_derivate1 contains the first derivate of dampedsignal, calculated by using the calculate.gold function. 

* timecol_derivate contains the values of time in which the derivative has been evaluated.

* excitation_rolled contains the roll mean of the excitation signal in embedding points.

* dampedsgnal_estimated contains the values of the estimated signal generated by using the generate.remi function and using the coefficients calculated for each individual.

If we want to visualize the summary of the mixed-effect regression:
  
```{r}
resultb1$regression
```

Where we have the random and fixed effects and the residuals calculated by the function lmer or lm depending on if the sample had several or one individuals respectively. 

Beware that the standard errors coming for this regression are not entirely correct as the calculation of derivatives "smoothes" the fit and underestimates them. Please see [(Mongin et al.,2018)](https://doi.org/10.1080/00273171.2010.498294) for more details.


The following table contains the average of these coefficients for all the individuals (result displayed by default when calling a doremi variable, as mentioned before):

```{r}
resultb1$resultmean
```

And for each individual we have:
  
```{r}
resultb1$resultid
```

Where:

* exccoeff is the coefficient of the excitation term. 

* dampingtime is the inverse of the damping coefficient. 

* eqvalue is the equilibrium value.

These values for exccoeff and eqvalue, as well as their homologues in the $resultmean table, have been calculated by extracting the coefficients from the regression and then multiplying them by the damping time.

If we graphically wish to verify how the estimated signal fits the initial signal, we can call the function "plot", that has been adapted to handle doremi objects:

```{r fig.width = 7, fig.height = 6}
plot(resultb1)
```

The values used to build the estimated signals are in [resultb1$restimated].

Similarly to the [print] function, [plot] applied to a doremi object plots by default the first six individuals contained in the result. If we wish to visualize a single individual or a specific set of individuals, we can specify them by changing the "id" input parameter of the function:

```{r fig.width = 7, fig.height = 6}
plot(resultb1, id = 3)
plot(resultb1, id = c(1,4))
```

## Example 2 -Analyzing data when the signal is subject to several excitations and no noise

In this example, the signal for each individual is set to depend of a linear combination of three excitation signals: 

$e(t)=a*e_{1}(t)+b*e_{2}(t)+c*e_{3}(t)$

```{r}
#Simulating data with these hypothesis
#Generating the three excitation signals:
e1 <- generate.excitation (amplitude = 10, 
                           nexc = 1, 
                           duration = 10, 
                           deltatf = 1, 
                           tmax = 100,
                           minspacing = 20)
e2 <- generate.excitation (amplitude = 10, 
                           nexc = 1, 
                           duration = 10, 
                           deltatf = 1, 
                           tmax = 100,
                           minspacing = 20)
e3 <- generate.excitation (amplitude = 10, 
                           nexc = 1, 
                           duration = 10, 
                           deltatf = 1, 
                            tmax = 100,
                           minspacing = 20)
# Arbitrarily choosing a = 1, b = 2 and c = 5 for the first individual
et1 <- e1$exc + 3 * e2$exc + 5 * e3$exc
timt1 <- e3$t  #we can use any of the three time vectors as they are identical for the three excitations
y1 <- generate.remi(dampingtime = 10,
                    inputvec = et1,
                    inputtim = timt1)$y 
#as we are using the $y argument ot the object generated

#Signals for the second individual;
# Arbitrarily choosing a = 1, b = 2.5 and c = 4 for the second individual
et2 <- e1$exc + 2.5 * e2$exc + 4 * e3$exc
y2 <- generate.remi(dampingtime = 10,
                    inputvec = et2,
                    inputtim = timt1)$y 

#Generating table with signals
mydatab2 <- list(id = rep(c(1, 2), c(length(et1), length(et2))), 
                 timecol = c(timt1, timt1),
                 excitation1 = c(e1$exc, e1$exc),
                 excitation2= c(e2$exc, e2$exc),
                 excitation3 = c(e3$exc, e3$exc),
                 excitation = c(et1, et2), 
                 signalcol = c(y1, y2))
```

```{r fig.width = 7,fig.height = 4}
#Plotting signals
ggplot2::ggplot( data = mydatab2 ) +
  ggplot2::geom_line(ggplot2::aes(timecol,signalcol, colour = "Signal-no noise"))+
  ggplot2::geom_line(ggplot2::aes(timecol,excitation,colour = "Excitation"))+
  ggplot2::facet_wrap(~id)+
  ggplot2::labs(x = "Time (s)",
           y = "Signal (arb. unit)",
           colour = "")
```

```{r}
#Analyzing signals
resultb2 <- remi(data = mydatab2,
                 id = "id",
                 input = c("excitation1", "excitation2", "excitation3"),
                 time ="timecol",
                 signal = "signalcol",
                 embedding = 5)

#Looking for the calculation of the coefficients of the excitation
resultb2$resultid
```

And, keeping into account the form of the analytical solution:
$$y(t) = \frac{\epsilon}{\tau}\int E(t')G(t-t')dt'+ eqvalue$$
One can find the excitation coefficients introduced either by extracting them from the summary of the regression or by taking the values from the $resultid table and dividing them by the damping time as explained before:

$\epsilon_{1}=1.18$, $\epsilon_{2}=3.36$, $\epsilon_{3}=5.76$ for individual 1 and
$\epsilon_{1}=1.18$, $\epsilon_{2}=2.78$, $\epsilon_{3}=4.62$ for individual 2, which are a good approximation of the coefficients set at the beginning of the example, using this small sample of 2 individuals.

```{r fig.width = 7,fig.height = 4}
#Plotting signals
plot(resultb2)
```

## Example 3 - Analyzing data when the excitation is unknown, with some inter- and intraindividual noise

Similarly to the example 2, we will generate data so that the analysis can fit a decreasing exponential, as is the case when there is no excitation, but also when the excitation is unknown, or the excitation is constant over time.  

```{r}
#Simulating data with these hypothesis
mydatab3 <- simulate.remi(nind = 6, 
                          dampingtime = 10, 
                          amplitude = -1,
                          nexc = 1, 
                          duration = 50, 
                          deltatf = 1,
                          tmax = 50,
                          minspacing = 0, 
                          internoise = 0.4, 
                          intranoise = 0.2)
```

Note that decreasing exponentials can be esaily generated through the simulation function by setting a negative amplitude of the excitation pulse and "extending" the pulse through all the time period.

```{r}
#Analysing
resultb3 <- remi(data = mydatab3,
                 id = "id",
                 time = "timecol",
                 signal = "dampedsignal",
                 embedding = 5)
```

Note that the _input_ parameter has been omitted when calling the function.

```{r  fig.width = 7, fig.height = 6}
#Plotting
plot(resultb3)
```

## Example 4 - Analyzing data from a single individual

In this case, we can reuse the signals of the example 2 for a single individual

```{r}
#Creating the data table
mydatab4 <- list(timecol = timt1,
                 excitation = et1, 
                 signalcol = y1)
```

Note that the _id_ parameter has been omitted when calling the function.

```{r}
#Analyzing
resultb4 <- remi(data = mydatab4,
                 input = "excitation",
                 time ="timecol",
                 signal = "signalcol",
                 embedding = 5)
```

```{r fig.width = 6,fig.height = 4, fig.pos = 0.5}
#Plotting 
plot(resultb4)
```

## Example 5 - Analyzing data when there is some missing points in the signal

When simulating signals with missing measurements, we examine how the analysis function still manages to retrieve an accurate fit:

```{r}
mydatab5 <- simulate.remi(nind = 4, 
                          dampingtime = 10, 
                          amplitude = 1, 
                          nexc = 3, 
                          duration = 10, 
                          deltatf = 0.5,
                          tmax = 100,
                          minspacing = 20,
                          internoise = 0.1, 
                          intranoise = 0.2)

#Keeping half of the rows selected randomly
mydatab5$data[, keep := sample(c(0,1), .N, replace = TRUE), by = id]
mydatab5rd <- mydatab5$data[keep == 1]

#Analysing the resulting signal
resultb5 <- remi(data = mydatab5rd,
                 id = "id",
                 input = "excitation",
                 time ="timecol",
                 signal = "dampedsignal",
                 embedding = 5)
```

Plotting sampling in signal with no noise:

```{r fig.width = 7,fig.height = 6}
ggplot2::ggplot( data = mydatab5$rawdata ) +
  ggplot2::geom_point(ggplot2::aes(timecol,dampedsignalraw, colour = "Pseudo-continuous signal. No noise"))+
  ggplot2::geom_line(ggplot2::aes(timecol,excitation,colour = "Excitation"))+
  ggplot2::geom_point(data = mydatab5rd, ggplot2::aes(timecol,dampedsignalraw, colour = "Random sampling"))+
  ggplot2::facet_wrap(~id)+
  ggplot2::labs(x = "Time (unit)",
           y = "Signal (unit)",
           colour = "")
```

Plotting analysis results:

```{r  fig.width = 7, fig.height = 6}
plot(resultb5)
```

# C - Applications

## C1 - Measuring heart frequency during effort tests.

Using the "cardio" dataset present in this package, the user will be able to apply the model to real heart frequency measurements. The data fields are described with detail in the "data.R" file,  as well as the source from which the data was obtained.

Summarizing, the data corresponds to 21 randomly chosen individuals that follow an "effort test" to measure heart resistance to stress. They need to pedal in a resistive bycicle to which a load is applied in watts. The more load, the greater effort the individual has to provide. His/her heart frequency will then vary according to the effort supplied.
According to this, the "cardio" data includes for each individual, the time since the beginning of the test (s), the bycicle load (W) and the heart rate (1/min).

The call to the analysis function to analyse this data would be as simple as:

```{r}
resultc1 <- remi(data = cardio,
                                id = "id",
                                input = "load",
                                time ="timecol",
                                signal = "hr",
                                embedding = 5)
```

Plotting analysis results:

```{r  fig.width = 10,fig.height = 10}
plot(resultc1, id = 1:21)
```

As it can be seen, the model reproduces considerably well the variation of the heart rate, and can be used to fully characterise the heart rate dynamics with three simple parameters: the resting heart rate (the equilibrium value), the characteristic time of heart rate change (the damping time), and the increase of heart rate for a given effort (the excitation coefficient).

## C2 - Meaurements of response time of individuals when carrying out mental rotation tasks

Using the "rotation" dataset present in this package, the user will be able to apply the model to the cases in which the excitation signal is not clearly defined or it is constant.

The data corresponds to 17 randomly chosen individuals that carried out several mental rotation tasks (identify if two figures are the same or not) and the response time (in ms) was measured. The purpose was to see if there was a variation of the response time according to the sex of the individual (and there was a variation indeed) and to observe the trends on the data.

The call to the analysis function to analyse this data would be:

```{r}
resultc2 <- remi(data = rotation,
                                id = "id",
                                time ="numtrials",
                                signal = "meanRT",
                                embedding = 5)
```

Plotting analysis results:

```{r  fig.width = 10, fig.height = 10}
plot(resultc2, id = 1:17)
```

As it can be seen, the decreasing exponential fit shows that response time is reduced throughout trials, indicating that the individual has learned and can execute the task faster by the end of the tests.

# D - Plot and predict with doremi objects

As it ws seen earlier, it is possible to plot doremi object direclt using the _plot_ function available in R. In the same way, an S3 method for the _predict_ function has been included to handle doremi objects. This means that it is possible to carry out an anlysis of a given signal and excitation and then use the analysis results to predict the signal that would be generated if another different excitation was provided. Let's take the example 2 of section B. In this example we anlyzed a single individual following a single excitation and we simulated two excitation vectors and two signals. 
In this section we will take the first of those excitations and the first of those signals to do the analysis, then use the results to carry out a prediction of the second signal to the second excitation. Finally, we will verify that the result of the predict function matches the second signal.
  
```{r   fig.width = 5,fig.height = 4, fig.pos = 0.5}
#Input data
#Taking et1,et2,y1 and y2 from example b2
#Create data frame with the pair e1,y1
mydata<-list(tim=timt1,exc=et1,y1=y1)

#Analysis 
resultd1 <- remi(data = mydata,
                           input = "exc",
                           time = "tim",
                           signal = "y1",
                           embedding = 5)
                                 
#Create data table with et2 that will be supplied as new excitation for the predict function
mydata$exc <- et2

#Calling the predict function
predresultd1<- predict (resultd1,
                       newdata = mydata)

#Compare with calculated signal y2
q<-plot(predresultd1)
q + ggplot2::geom_point(ggplot2::aes(predresultd1$data$tim, y2,colour = "y2"))
```
